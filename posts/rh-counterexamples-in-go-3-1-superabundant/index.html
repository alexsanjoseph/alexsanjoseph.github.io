<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.88.1" />

    
    
    

<title>Searching for RH Counterexamples in Golang - Superabundant Numbers • Alex&#39;s Blog</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Searching for RH Counterexamples in Golang - Superabundant Numbers"/>
<meta name="twitter:description" content=""/>

<meta property="og:title" content="Searching for RH Counterexamples in Golang - Superabundant Numbers" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/rh-counterexamples-in-go-3-1-superabundant/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-29T10:17:52+00:00" />
<meta property="article:modified_time" content="2022-10-31T20:23:45+05:30" /><meta property="og:site_name" content="Alex&#39;s Blog" />



    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.a49b6ba6c4955c432d9ded493e8ac2653879067ed0659625ca96a85e8747609f.css" integrity="sha256-pJtrpsSVXEMtne1JPorCZTh5Bn7QZZYlypaoXodHYJ8=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="icon" href="/icon.png">
    <link rel="shortcut icon" href="/icon.png">
    
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="/">Alex&#39;s Blog</a>
      </span>
      
        
        
        
        <div class="author-image">
          <img src="/images/alex.jpeg" alt="Author Image" class="img--circle img--headshot element--center">
        </div>
        
      
      
      <p class="site__description">
         Pasting random things together 
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Alex&#39;s Blog</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/portfolio/">
						<span>Portfolio</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	<a href="https://twitter.com/alexsanjoseph" rel="me"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a>
	
	
	
	<a href="https://github.com/alexsanjoseph" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/alexsanjoseph" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	<a href="https://stackoverflow.com/users/1653808/alex-joseph" rel="me"><i class="fab fa-stack-overflow fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
	<a href="mailto:alexsanjoseph%20at%20gmail.com" rel="me"><i class="fas fa-at fa-lg" aria-hidden="true"></i></a>
	
</section>

      </div>
    </div>
    
<div class="copyright">
  &copy; 2016 - 2022 alexsanjoseph
  
</div>


<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Searching for RH Counterexamples in Golang - Superabundant Numbers</h1>
    
    
<div class="post__meta">
    </script>
    
    
    <i class="fas fa-calendar-alt"></i> Created: 2022 Oct 29
    
    
    
    , Updated:
    2022 Oct 31
    
    
    
    
    
    
    
    <br />
     <i class="fas fa-tags"></i>
    
    <a class="badge badge-tag" href="/tags/golang">golang</a>
     
    
    <a class="badge badge-tag" href="/tags/riemann-hypothesis">riemann-hypothesis</a>
     
    
    <a class="badge badge-tag" href="/tags/superabundant">superabundant</a>
    
    
    
    
    <br />
    <i class="fas fa-clock"></i> 8 min read
</div>

  </header>
  
  
  <div class="post">
    <h2 id="intro">Intro</h2>
<p>In the <a href="../rh-counterexamples-in-go-1-database/">last post</a>, we added persistence to our search by adding a database. This ensured that we didn&rsquo;t lose any of the work that we did, but still the progress was pretty slow and we didn&rsquo;t move much past millions in the search. We were considering every number as a potential candidate for a <code>Riemann Counterexample</code>. However, on inspection, we can see that the high <code>witness values</code> are all created by numbers that have a lot of divisors. Can we focus our search <em>only</em> on these numbers?</p>
<blockquote class="info">
    <strong>As always, credits go to the original author <a href="https://jeremykun.com/2020/09/28/searching-for-rh-counterexamples-search-strategies/">here</a></strong><br>
    
</blockquote>
<h2 id="superabundant-numbers">Superabundant Numbers</h2>
<p>In mathematics, numbers that have the sum of their factors that add up to more than the number itself are called <a href="https://en.wikipedia.org/wiki/Abundant_number">abundant numbers</a></p>
<p>$$\phi(n) &gt; n$$</p>
<p>where $\phi(n)$ refers to the sum of factors of n. It is easy to see how these numbers are prime candidates for a Riemann counterexample since they have a high chance of a high sum of divisors.</p>
<p>Among abundant numbers, some numbers are called <code>superabundant</code> which have the property of &ldquo;maximal relative divisor sums&rdquo;, i.e, these are the numbers that have the the ratio of the sum of divisors to itself is larger than every number smaller than itself. This can be expressed as:</p>
<p>$$
\frac{\sigma_m}{m} \lt \frac{\sigma_n}{n} \hspace{1em} \forall \hspace{1em} m &lt;n
$$</p>
<p>While there is no easy strategy to find superabundant numbers, it <a href="https://doi.org/10.2307%2F1990319">has been proved</a> that superabundant numbers have to have a prime decomposition where all the prime factors occur in non-increasing exponents:</p>
<p>$$n = \prod_{i=1}^n {p_i}^{a_i}$$</p>
<p>where $p_i$ is the <code>i</code>th prime factor and $a_i \leq a_{i-1}$.</p>
<p>The non-increasing list of numbers that add to a number is called a <code>partition</code>. We just need to find the partitions of a number, and combine them with the non-increasing prime factor and we&rsquo;re well on our way to a better approach to solve this problem.</p>
<h2 id="finding-partitions">Finding Partitions</h2>
<p>There are pretty standard methods to find partitions, one of which was included in the original post. However, I found the algorithm a bit difficult to understand and hence ended up <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4/commits/ab34c1977440eae9d3f2f098a0f3bca8bd0eeace">implementing</a> a simple recursion algorithm instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">PartitionsOfN</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">output</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{{<span style="color:#a6e22e">n</span>}}
	<span style="color:#a6e22e">arrayToAdd</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
	<span style="color:#a6e22e">splitPoint</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">arrayToAdd</span>[<span style="color:#a6e22e">splitPoint</span>] = <span style="color:#a6e22e">n</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">newParts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">PartitionsOfN</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">i</span>)
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">part</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">newParts</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">part</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">i</span> {
				<span style="color:#a6e22e">output</span> = append(<span style="color:#a6e22e">output</span>, append([]<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">i</span>}, <span style="color:#a6e22e">part</span><span style="color:#f92672">...</span>))
			}
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">output</span>
}

</code></pre></div><p>Quite simply, partitions of a number are the previous partitions ($n-1$), plus the partitions created by the additional number.While this approach worked and found the right set of partitions, the algorithm grinded to a halt as we approached $n&gt;25$! A similar slowdown was seen for the <code>Kun/Python</code> algorithm only around $n&gt;70$ so we definitely needed to do better!</p>
<p>On inspection, I realized that for each number, the algorithm was calculating the partitions for all the smaller numbers again and again, duplicating the work. In <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4/commits/341ac8fa2a98a18ac53d6a8a32ba72806c64c442">this commit</a>, I implemented <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> which calculates the partitions only if the number was new, otherwise reading from the existing cache. This approach of <code>memoization</code> + <code>recursion</code> is called <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">cachedPartitionsOfN</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">cache</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>][][]<span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">possibleOutput</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">n</span>]
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">possibleOutput</span>
	}

	<span style="color:#a6e22e">output</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{{<span style="color:#a6e22e">n</span>}}
	<span style="color:#a6e22e">arrayToAdd</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">n</span>)
	<span style="color:#a6e22e">splitPoint</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">arrayToAdd</span>[<span style="color:#a6e22e">splitPoint</span>] = <span style="color:#a6e22e">n</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &gt; <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">newParts</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cachedPartitionsOfN</span>(<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">cache</span>)
		<span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">n</span><span style="color:#f92672">-</span><span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">newParts</span>
		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">part</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">newParts</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">part</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">i</span> {
				<span style="color:#a6e22e">output</span> = append(<span style="color:#a6e22e">output</span>, append([]<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">i</span>}, <span style="color:#a6e22e">part</span><span style="color:#f92672">...</span>))
			}
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">output</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MemoizedPartitionsOfN</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) [][]<span style="color:#66d9ef">int</span> {
	<span style="color:#a6e22e">cache</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>][][]<span style="color:#66d9ef">int</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cachedPartitionsOfN</span>(<span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">cache</span>)
}
</code></pre></div><p>This significantly sped up the process and we were able to approach partition computation speeds on par with the <code>Python</code> approach.</p>
<blockquote class="info">
    <strong>At this point, I noticed some minor discrepancy between the results of my approach and the original authors approach. To verify, <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4/commits/bd1f673ec2bb01bf2a9eca6186e33ad24ab03656">I implemented the same myself</a> and saw the the issue is persisting and raised a <a href="https://github.com/j2kun/riemann-divisor-sum/issues/39">bug report</a> which the author fixed promptly!</strong><br>
    
</blockquote>
<p>Now that we had the partitions, finding the prime factor divisor sum <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/blob/be440d2bd29c2c7ca2d6131ef53c1c86cef3367a/riemann/divisor.go">is straightforward</a>.</p>
<h2 id="property-testing">Property Testing</h2>
<p>In general, we add tests by manually computing the expected value and then comparing the results of a function with the expected value to see if it matches correctly. This kind of testing is useful primarily in preventing regressions, where a further change can accidentally break existing functionality. However, this rarely captures edge cases that the programmer herself hasn&rsquo;t thought of. We can mitigate some of this by using <code>property tests</code>.</p>
<p>In the case of <a href="https://en.wikipedia.org/wiki/Software_testing#Property_testing">Property Tests</a>, the test cases are generated automaticallyat test time. After that, the expected output is checked based on a specific property of the expected output.</p>
<p>For example, let us assume we are implementing the <code>square</code> function. We usually test the function by checking the value of squares for a few numbers.</p>
<ul>
<li>square(1) = 1</li>
<li>square(2) = 4</li>
<li>square(11) = 121</li>
</ul>
<p>While this might look sufficient, this doesn&rsquo;t necessarily capture edge cases. For example our algorithm might fail for</p>
<ul>
<li>negative numbers</li>
<li>fractional numbers</li>
<li>irrational numbers</li>
<li>large numbers</li>
<li>very small numbers etc.</li>
</ul>
<p>So instead of trying to account for every possible number, we instead give properties of the squaring function that we know:</p>
<ul>
<li>Square of any number is positive</li>
<li>Square of any number &gt; 1 should be greater than itself</li>
<li>Square of any number &lt;1 should be less than itself</li>
<li>Square of any integer is another integer</li>
<li>Square of any fraction is a fraction.</li>
</ul>
<p>This kind of an approach can find out many hidden bugs in the code and is essential for all mission critical code!</p>
<p>In our case, we add the property tests by calculating the <code>Prime Factor Divisor Sum</code> using the naive approach to validate our tests. In <code>Golang</code>, the <code>gopter</code> package allows you to quickly generate hypothesis tests and customize it to your hearts content.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#a6e22e">parameters</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gopter</span>.<span style="color:#a6e22e">DefaultTestParameters</span>()
<span style="color:#a6e22e">parameters</span>.<span style="color:#a6e22e">MinSuccessfulTests</span> = <span style="color:#ae81ff">100</span>
<span style="color:#a6e22e">parameters</span>.<span style="color:#a6e22e">MaxSize</span> = <span style="color:#ae81ff">10</span>
<span style="color:#a6e22e">properties</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">gopter</span>.<span style="color:#a6e22e">NewProperties</span>(<span style="color:#a6e22e">parameters</span>)

<span style="color:#a6e22e">properties</span>.<span style="color:#a6e22e">Property</span>(<span style="color:#e6db74">&#34;Check Prime Factor Divisor Sum&#34;</span>, <span style="color:#a6e22e">prop</span>.<span style="color:#a6e22e">ForAll</span>(
    <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {

        <span style="color:#a6e22e">smallerSliceLength</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">b</span>)
        <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">&lt;=</span> len(<span style="color:#a6e22e">b</span>) {
            <span style="color:#a6e22e">smallerSliceLength</span> = len(<span style="color:#a6e22e">a</span>)
        }
        <span style="color:#a6e22e">input</span> <span style="color:#f92672">:=</span> [][]<span style="color:#66d9ef">int</span>{}
        <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> int64(<span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">smallerSliceLength</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
            <span style="color:#a6e22e">input</span> = append(<span style="color:#a6e22e">input</span>, []<span style="color:#66d9ef">int</span>{<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>]})
            <span style="color:#a6e22e">n</span> <span style="color:#f92672">*=</span> int64(<span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(float64(<span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>]), float64(<span style="color:#a6e22e">b</span>[<span style="color:#a6e22e">i</span>])))
        }

        <span style="color:#a6e22e">resultA</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">riemann</span>.<span style="color:#a6e22e">PrimeFactorDivisorSum</span>(<span style="color:#a6e22e">input</span>)
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
        }

        <span style="color:#a6e22e">resultB</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">riemann</span>.<span style="color:#a6e22e">DivisorSum</span>(<span style="color:#a6e22e">n</span>)

        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
        }

        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">resultA</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">resultB</span>

    },
    <span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">SliceOf</span>(<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">IntRange</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">20</span>).<span style="color:#a6e22e">SuchThat</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> { <span style="color:#75715e">// Have to constrain because it doesn&#39;t work for large numbers yet
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">riemann</span>.<span style="color:#a6e22e">CheckIfPrime</span>(<span style="color:#a6e22e">v</span>.(<span style="color:#66d9ef">int</span>))
    }),
        <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(int(<span style="color:#ae81ff">0</span>))).<span style="color:#a6e22e">SuchThat</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">riemann</span>.<span style="color:#a6e22e">CheckUniqueness</span>(<span style="color:#a6e22e">v</span>.([]<span style="color:#66d9ef">int</span>))
    }).<span style="color:#a6e22e">WithLabel</span>(<span style="color:#e6db74">&#34;a&#34;</span>),
    <span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">SliceOf</span>(<span style="color:#a6e22e">gen</span>.<span style="color:#a6e22e">IntRange</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>),
        <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(int(<span style="color:#ae81ff">0</span>))).<span style="color:#a6e22e">WithLabel</span>(<span style="color:#e6db74">&#34;b&#34;</span>),
))
<span style="color:#a6e22e">Expect</span>(<span style="color:#a6e22e">properties</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">gopter</span>.<span style="color:#a6e22e">ConsoleReporter</span>(<span style="color:#66d9ef">true</span>))).<span style="color:#a6e22e">To</span>(<span style="color:#a6e22e">BeTrue</span>())

</code></pre></div><p>In the above code, I randomly generate bases between 2 and 20 (while constraining them to be prime and unique), and exponents between 0 to 5. This testing actually managed to find specific issues with my first implementation that I had missed out!</p>
<ul>
<li>The algorithm doesn&rsquo;t work with non-prime bases, for which I had added guard rails.</li>
<li>The algorithm doesn&rsquo;t work if the bases are not unique, which I hadn&rsquo;t accounted for either in the first implementation.</li>
<li>The algorithm doesn&rsquo;t work for larger numbers because of integer overflow (and exponentiation creates large numbers really fast!), which couldn&rsquo;t solve yet.</li>
</ul>
<p>I added code in addition to the property tests and regular tests in <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4/commits/be440d2bd29c2c7ca2d6131ef53c1c86cef3367a">this commit</a>.</p>
<p>Now that we are sold on property tests, we can also circle around and <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4/commits/4179ab9033fdfe918ee744c8330f8adc3df7ec8b">add property tests for the <code>partitions</code> code</a>. We check for the following properties:</p>
<ul>
<li>Sum of all partitions should add up to the original number</li>
<li>The partition values themselves are non-increasing</li>
<li>Partitions are sorted</li>
<li>Partitions are unique.</li>
</ul>
<p>Thankfully, our partitions algorithm was already beyond reproach ;) and we didn&rsquo;t have to change any code!</p>
<h2 id="dealing-with-really-large-numbers">Dealing with (REALLY) Large Numbers</h2>
<p>The one issue that we identified which we had avoided till now was dealing with large numbers. Even if we are using 64 bit integers (which are the largest primitives in <code>Golang</code>) while doing the math, it turns out that we max-out at a paltry <code>9223372036854775807</code> which is not going to be nearly enough if we&rsquo;re going to find a counterexample.</p>
<blockquote class="info">
    <strong>Native <code>Python</code> doesn&rsquo;t face this issue since large number math is handled internally by <code>Python</code>, but the moment we try to optimize the code by using packages like <code>numpy</code> and <code>numba</code>, we have the same problem!</strong><br>
    
</blockquote>
<p>Thankfully, <code>Golang</code> has a standard way of dealing with this by using the <code>math/big</code> package. While using the package is a bit more clunky than native numbers, it allows you to do all the math required to solve our problem. In <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4/commits/29743a7cc1b9307a9d3eb58d4d1dafa89cdab575">this commit</a> I upgrade the numbers to <code>Bigint</code> and add a few more tests. This allows us to remove the constraint on large numbers (now the constraints are only to make sure that the tests run within a reasonable time!)</p>
<h2 id="next-steps">Next steps</h2>
<p>All the commits above are condensed into <a href="https://github.com/alexsanjoseph/riemann-divisor-sum-go/pull/4">this</a> pull request.</p>
<p>We are all set to solve the actual problem, since we have the subset of numbers that we need to search as candidates for a <code>Reimann counterexample</code>.</p>
<p>In the next post, we will use the candidates we found using this approach to solve the Riemann Hypothesis problem.</p>
<blockquote >
    <strong>Cover art: <em>Interpretation of abundance, according to the Stable Diffusion AI</em></strong><br>
    
</blockquote>
  </div>
  


  

  
    
        <div id="graphcomment"></div>
<script type="text/javascript">
  window.graphcomment_id = 'blog-alexsanjoseph-com';
   
  (function() {
    var gc = document.createElement('script'); gc.type = 'text/javascript'; gc.async = true;
    gc.src = 'https://graphcomment.com/js/integration.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(gc);
  })();
</script>
    


</article>


        </div>
        
    

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-179464703-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.11.2/js/all.js"
    integrity="sha384-b3ua1l97aVGAPEIe48b4TC60WUQbQaGi2jqAWM90y0OZXZeyaTCWtBTKtjW2GXG1"
    crossorigin="anonymous"></script>
<script data-goatcounter="https://alexsanjoseph.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
<script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
     inlineMath: [['$','$'], ['\\(','\\)']],
     displayMath: [['$$','$$']],
     processEscapes: true,
     processEnvironments: true,
     skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
     TeX: { equationNumbers: { autoNumber: "AMS" },
            extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>
<script>
    
    
    
    window.goatcounter.visit_count({ append: 'body' })
</script>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    



    



    </body>
</html>
